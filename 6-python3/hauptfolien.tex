%%% Folie
\begin{frame}{Ausgangslage}
    Hier die Ausgangslage/Motivation für das Kapitel beschreiben ...

    % UNGEFÄHRE AUSSAGE
    %
    % Die einfachen Programmbeispiele der vorangegangen Kapitel eignen sich in der
    % Regel kaum für produktive Anwendungen, da sie einem einfachen, prozeduralen
    % Programmierstil gehorchen, bei dem jeder Methodenaufruf den rufenden Thread
    % so lange blockiert, bis die gewünschte Aktion durchgeführt wurde. Auf diese
    % Weise lassen sich daher nur sehr wenige Sensoren und Aktoren verbinden und
    % bestimmte Anwendungsfälle, wie die Bereitstellung einer deviceseitigen REST-API
    % lassen sich auf diese Weise gar nicht realisieren. Darüber hinaus wird der
    % Quellcode auch schnell sehr komplex und unübersichtlich, je mehr Komponenten
    % integriert werden sollen. Dieses Kapitel soll daher die wesentlichen
    % Architekturmuster zeigen, mit denen sich komplexe Pythonprogramme in lose
    % gekoppelte Einheiten zerlegen lassen, die eine einfache Erweiterbarkeit und
    % Wartbarkeit des Quellcodes (z.B. wenn eine Komponente ausgetauscht werden
    % muss) ermöglichen.
\end{frame}

%%% Folie
\begin{frame}{Lernziele}
    \begin{itemize}
        \item Komplexe Anwendungsfälle objektorientiert modellieren können
        \item Python-Anwendungen mit Klassen und Modulen modularisieren können
        \item Die Nachteile einer zu engen Kopplung von Klassen verstehen können
        \item Entwurfsmuster Observer und Message Broker anwenden können
        \item Nebenläufige Programmierung mit Threads in Python
        %\item Nebenläufige Programmierung mit Coroutinen in Python
    \end{itemize}
\end{frame}


%-------------------------------------------------------------------------------
\section{Design Patterns}
%-------------------------------------------------------------------------------

%%% Folie
\begin{frame}{Übersicht}
    TODO
\end{frame}

%%% Folie
\begin{frame}{DI und IOC Intro}
  Definition, GoF, Loose Coupling (Grafik)
\end{frame}

%%% Folie
\begin{frame}{DI und IOC Anwendungsfall}
   TODO
 \end{frame}
 
 %%% Folie
\begin{frame}{DI in Python Einfach}
TODO
  \end{frame}

%%% Folie
\begin{frame}{Container Injection}
TODO
  \end{frame}

%%% Folie
\begin{frame}{Python Konstrukte}
    Monkey Patching, Mixins
\end{frame}

%%% Folie
\begin{frame}{Testing mit MagicMock}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Observer Pattern}
    Definition,Grafik
\end{frame}

%%% Folie
\begin{frame}{Publish-Subscribe}
   % https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c
\end{frame}

%%% Folie
\begin{frame}{Anwendungsfall Teil 1 - Projektstruktur}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Anwendungsfall Teil 2 - Code}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%-------------------------------------------------------------------------------
\section{Nebenläufigkeit in Python}
%-------------------------------------------------------------------------------

%%% Folie
\begin{frame}{Nebenläufigkeit vs. Parallelität - Intro}
        \begin{itemize}
        \setlength{\itemindent}{2.0in}
        \item [\textbf{Definition: Nebenläufig vs. Parallel}]
    \end{itemize}

    \begin{itemize}
        \item Als \textbf{nebenläufig} definieren wir Aufgaben, die auf einem Computer um Ressourcen konkurrieren und nicht notwendigerweise gleichzeitig ausgeführt werden (können). Der Fokus liegt auf dem Ausführen und Organisieren mehrerer eventuell unabhängiger Aufgaben
        \item Als \textbf{parallel} definieren wir nebenläufige Aufgaben, die gleichzeitig ausgeführt werden (können). Der Fokus liegt aber auf Leistung.
     \end{itemize}
\end{frame}

\begin{frame}{Nebenläufigkeit vs. Parallelität - Beispiele}
        \begin{itemize}
        \setlength{\itemindent}{2.2in}
        \item [\textbf{Beispiele: Nebenläufig oder Parallel?}]
    \end{itemize}

    \begin{itemize}
        \item Abfrage der Werte verschiedener angeschlossener Sensoren $\Rightarrow$ nebenläufig
        \item Schnelle unabhängige Sortierung von Werten $\Rightarrow$ (embarassingly) parallel
        \item Gleichzeitige Anzeige von Dashboard Daten und Erfassung der Messwerte $\Rightarrow$ nebenläufig
        \item Mathematische Transformationen (Filter, Computer Vision) auf Kamerabildern  $\Rightarrow$ parallel %http://files.hanser.de/Files/Article/ARTK_LPR_9783446449336_0001.pdf
        \item Versand von Nachrichten über das Internet aus verschiedenen Modulen eines Programms  $\Rightarrow$ nebenläufig
     \end{itemize}
\end{frame}

\begin{frame}{Raspberry PI 3 und Nebenläufigkeit}
     \begin{itemize}
        \setlength{\itemindent}{1.0in}
        \item [\textbf{Raspberry PI 3b}]
    \end{itemize}
    \begin{itemize}
        \item Quadcore CPU
        \item Benchmarks für z.B. Primzahlberechnung oder Unzip  mit deutlichem Geschwindigkeitsvorteil
     \end{itemize}
  \begin{figure}[!htb]
  \hspace*{-4cm}   
        \includegraphics[scale=0.075]{6-python3/img/raspi3}  %https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Rasperry_pi_3_model_b_v1.3_bot.jpg/2560px-Rasperry_pi_3_model_b_v1.3_bot.jpg
    \end{figure}

\end{frame}

\begin{frame}{Raspberry PI 3 Cluster}
	  \begin{figure}[!htb]
        \includegraphics[scale=0.23]{6-python3/img/raspi3cluster}  %https://www-users.cs.york.ac.uk/~mjf/pi_cluster/Images/cluster1.jpg
    \end{figure}

\end{frame}

\begin{frame}{Recap: Threads vs. Prozesse}
    
     \begin{itemize}
        \setlength{\itemindent}{1.2in}
        \item [\textbf{Definition: Prozess}]
    \end{itemize}

    \begin{itemize}
        \item Als \textbf{Prozess} definieren wir ein Programm in Ausführung, dessen Speicher und Laufzeit durch das Betriebssystem verwaltet wird
     \end{itemize}
    
  	   \vspace*{10mm}
    
    
         \begin{itemize}
        \setlength{\itemindent}{1.2in}
        \item [\textbf{Definition: Thread}]
    \end{itemize}

    \begin{itemize}
        \item Als \textbf{Thread} definieren wir einen nebenläufigen Teil eines Prozesses in Ausführung, dessen Speicherbereich in dem des Prozesses liegt
     \end{itemize}
    
    \end{frame}



\begin{frame}{Python GIL 1}
                 \begin{itemize}
        \setlength{\itemindent}{1.9in}
        \item [\textbf{Python Global Interpreter Lock }]
    \end{itemize}
    \begin{itemize}
        \item Das GIL ist ein Sperrmechanismus (Mutex mit Variable), um den Python Interpreter stets auf einen kontrollierenden Thread zu beschränken  \cite{realpython.com/python-gil}
        \item Grund: Speicherreferenzen werden in Python ermittelt und das geht mit dem GIL deterministisch $\Rightarrow$ viele Memory Leaks werden so verhindert, im Code muss man nicht ständig alles selbst mit Locks sperren
    \end{itemize}
    
    \end{frame}
    
\begin{frame}{Python GIL 2}
                 \begin{itemize}
        \setlength{\itemindent}{1.0in}
        \item [\textbf{Was heißt das? }]
    \end{itemize}
    \begin{itemize}
        \item Konsequenz:  Jeder Thread muss sich stets erst das GIL holen und kann dann laufen, weshalb CPU-lastige Aufgaben so nicht parallelisierbar sind
         \item Abhilfe:  Mit Prozessen arbeiten statt mit Threads - oder anderen Python Interpreter wählen, der ohne GIL arbeitet (kommt via Subinterpreter mit Python 3.9 in PEP-0554 \cite{python.org/dev/peps/pep-0554})
    \end{itemize}
    
    \end{frame}

\begin{frame}{Python Multiprocessing}
          \begin{itemize}
        \setlength{\itemindent}{1.4in}
        \item [\textbf{Multiprocessing Modul}]
    \end{itemize}
    \begin{itemize}
        \item Das Python Modul \textbf{multiprocessing} kann verwendet werden für CPU-lastige Aufgaben
        \item Aber Vorsicht: Prozess Handling ist tfür das Betriebssystem eurer wegen des komplexeren Kontextwechsels
        \item Hauptobjekt: Prozess $\Rightarrow$   \texttt{multiprocessing.Process(name='CalculationXY', target=my\_callback\_function)}
        \item Wichtiger Check zur Vermeidung von Endlosrekursion:   \texttt{if \_\_name\_\_ == '\_\_main\_\_'}
        \item Pool $\Rightarrow$ eine Prozessgruppe eine gemeinsame Aufgabe ausführen lassen durch Übergabe eines Callbacks
    \end{itemize}
\end{frame}

\begin{frame}{Python Multiprocessing Beispiel: Annhäherung von $\pi$} %https://gist.github.com/amitsaha/2036026
      \begin{figure}[!htb]
        \includegraphics[scale=0.27]{6-python3/img/multiprocessing_picalc}
    \end{figure}

\end{frame}

%%% Folie
\begin{frame}{Threads in Python}
         \begin{itemize}
        \setlength{\itemindent}{1.4in}
        \item [\textbf{Thread Handling Module}]
    \end{itemize}
    \begin{itemize}
        \item Das Python Modul \textbf{thread} ist das ältere Modul  mit Callbacks  $\Rightarrow$  \texttt{thread.start\_new\_thread ( cb, args[, kwargs] )}
        \item \textbf{threading} ist das modernere Modul, welches OOP verwendet und es ist in Python 3 enthalten
        \item Das Modul \textbf{threading} wird sehr ähnlich verwendet wie \textbf{multiprocessing}, mit Klassen \texttt{Thread} und \texttt{ThreadPoolExecutor}
    \end{itemize}

\end{frame}

%%% Folie
\begin{frame}{Beispiel Ping mit Threads}
  %https://www.python-kurs.eu/threads.php
    \begin{figure}[!htb]
        \includegraphics[scale=0.23]{6-python3/img/pingthreads}
    \end{figure}

\end{frame}

%%% Folie
\begin{frame}{Thread Probleme}
         \begin{itemize}
        \setlength{\itemindent}{2.2in}
        \item [\textbf{Probleme beim Umgang mit Threads}]
    \end{itemize}
    \begin{itemize}
        \item Race Condition  $\Rightarrow$  Zugriff auf gemeinsame Daten führt  \quotes{random} zu unerwarteten Ergebnissen
        \item Lost Update $\Rightarrow$  Der letzte Schreibzugriff gewinnt
        \item Deadlock $\Rightarrow$  Jeder Thread wartet darauf, dass er die Freigabe zum laufen erhält (wurde z.B. vergessen oder ein Bug)
    \end{itemize}
\end{frame}

%%% Folie
\begin{frame}{Locks}
   Definition, Nutzen, with statement
\end{frame}


%%% Folie
\begin{frame}{Queue}
   Definition, Nutzen, with statement
\end{frame}

%%% Folie
\begin{frame}{Producer $\Rightarrow$  Consumer} %https://www.agiliq.com/blog/2013/10/producer-consumer-problem-in-python/
     \begin{figure}[!htb]
        \includegraphics[scale=0.31]{6-python3/img/producerconsumer} 
    \end{figure}
\end{frame}

%%% Folie
\begin{frame}{asyncio, twisted, tornado}

Is it IO-BOUND ? ---------> USE asyncio, uvloop

IS IT CPU-HEAVY ? -----> USE multiprocessing

ELSE ? ----------------------> USE threading
\end{frame}

%%% Folie
\begin{frame}{Coroutines}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}

%%% Folie
\begin{frame}{Folie}
    TODO
\end{frame}


