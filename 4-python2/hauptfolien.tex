%%% Folie
\begin{frame}{Lernziele}
    \begin{itemize}
       \item  Bedeutung von Zeitstempeln
        \item Möglichkeiten zum Abspeichern von Sensorwerten kennenlernen       
        \item Interrupts als alternative Methode nutzen können, um Sensorwerte auszulesen
    \end{itemize}
\end{frame}
 
 
 %-------------------------------------------------------------------------------
\section{Zeitstempel}
%-------------------------------------------------------------------------------

%%% Folie
\begin{frame}{Wozu werden Zeitstempel benötigt?}
    \begin{itemize}
        \setlength{\itemindent}{1.9in}
        \item [\textbf{Wesentliche Funktionen im IoT}]
    \end{itemize}

    \begin{itemize}
        \item Protokollierung von Ereignissen
        \item Tracing von Nachrichten
        \item Speichern von Sensorwerten als Historie
        \item Programmierung von Ablauflogiken
        \item ...
     \end{itemize}
\end{frame}


\begin{frame}[fragile]{Zeitstempel - Logging 1}
    \begin{itemize}
        \setlength{\itemindent}{1.9in}
        \item [\textbf{Protokollierung von Ereignissen}]
    \end{itemize}

    \begin{itemize}
              \item Log Files enthalten Informationen über den zeitlichen Ablauf des Programmes
               \item Fehler können in einen zeitlichen Zusammenhang gebracht werden
     \end{itemize}
     
    \begin{lstlisting}[language=Python, gobble=8]
        # Logging Konfigurieren mittels JSON Datei
           import os
           import json
           import logging.config
           def setup_logging(default_path='config/logging.json', default_level=logging.INFO, env_key='LOG_CFG'):
              path = default_pat
              dirname = os.path.dirname(__file__)
              filename = os.path.join(dirname, path)
              value = os.getenv(env_key, None)
              if value:
                path = value
              if os.path.exists(filename):
                 with open(filename, 'rt') as f:
                   config = json.load(f)
                   logging.config.dictConfig(config)
              else:
                   logging.basicConfig(level=default_level)    
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Zeitstempel - Logging 2}
    \begin{itemize}
        \setlength{\itemindent}{1.4in}
        \item [\textbf{Konfiguration der Logger}]
    \end{itemize}

    \begin{itemize}
         \item Verschiedene Handler für Ausgaben möglich (Files, Console, Monitoring Server im Netz etc.)
         \item Zeitstempel lassen sich über Formatter konfigurieren
     \end{itemize}
     
    \begin{lstlisting}[language=Java, gobble=8]
         // Logging Konfiguration aus der Datei: config/logging.json
           {   "version": 1,
               "disable_existing_loggers": false,
               "formatters": {
                    "simple": {
                       "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
                    }
                },
               "handlers": {
                    "info_file_handler": {
                        "class": "logging.handlers.RotatingFileHandler",
                        "level": "INFO",
                        "formatter": "simple",
                        "filename": "my_app.log",
                        "maxBytes": 10485760,
                        "backupCount": 5,
                        "encoding": "utf8"
                  }
               "root": {
                    "level": "INFO",
                    "handlers": ["info_file_handler"]
               }
          }
        \end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Zeitstempel - Tracing}
    \begin{itemize}
        \setlength{\itemindent}{1.4in}
        \item [\textbf{Tracing von Nachrichten}]
    \end{itemize}

    \begin{itemize}
              \item Idee: Daten auf einem Gerät A zum Zeitpunkt x erfassen und als Nachricht versenden
               \item Gerät B (z.B. ein weiterer Raspberry Pi oder ein Server) soll die Nachricht erhalten
               \item Zeitstempel wird auf Gerät A an eine zu übertragende Nachricht angehängt
               \item Wenn Gerät B die Nachricht erhält, kann dort ermittelt werden, von wann die Nachricht ist (z.B. im Log von Gerät B nachschauen)
     \end{itemize}

\end{frame}


\begin{frame}[fragile]{Zeitstempel - Format 1}
    \begin{itemize}
        \setlength{\itemindent}{2.4in}
        \item [\textbf{Wie sollten Zeitstempel formatiert sein?}]
    \end{itemize}

    \begin{itemize}
              \item Aktuell 38 verwendete Zeitzonen weltweit (siehe \url{https://www.timeanddate.com/time/current-number-time-zones.html})
               \item ISO 8601 als Standard für Formatierung menschenlesbarer Zeitstempel
               \item Beispiel: 2019-10-31T16:56:34.297+02:00 $\rightarrow$ Uhrzeit inkl. Millisekunden vom 31 Oktober, 2 Stunden "Offset" auf die UTC Weltzeit addiert 
               \item Gewöhnlich werden die Daten zu UTC formatiert, also hier 2019-10-31T14:56:34.297+00:00 oder auch Zulu-Zeit: 2019-10-31T14:56:34.297Z
               \item Mit UTC/Zulu kann überall eine lokale Uhrzeit ermittelt werden, wir müssen also für die Deutsche Sommerzeit +2 Stunden auf den UTC Zeitstempel addieren 
     \end{itemize}
       \begin{lstlisting}[language=Python, gobble=8]
        # Beispiel: aktuellen Zeitstempel nehmen und ausgeben          
           from datetime import datetime,timezone

           current_timestamp = print(datetime.now(timezone.utc).isoformat(timespec='milliseconds')) # aktueller Zeitstempel
           #  Ausgabe bspw: 2019-10-31T10:42:16.634+00:00 
        \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Zeitstempel - Format 2}
    \begin{itemize}
        \setlength{\itemindent}{2.4in}
        \item [\textbf{Aber woher bekommen wir den Offset?}]
    \end{itemize}

    \begin{itemize}
              \item  Den Offset könnte man fest einstellen, wenn man weiß, wo das Gerät voraussichtlich aufgestellt sein wird
               \item Besser: UTC Zeitstempel holen von einem Remote Server
               \item Hier kommt das NTP Protokoll zum Einsatz (siehe \url{https://tools.ietf.org/html/rfc5905})
               \item Der Raspberry kann systemseitig mit NTP synchronisieren
               \item Auch möglich: NTP Client via pip install ntplib
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Zeitstempel - Format 3}
    \begin{itemize}
        \setlength{\itemindent}{2.4in}
        \item [\textbf{}]
    \end{itemize}

  \begin{lstlisting}[language=Python, gobble=8]
        # Beispiel: Zeitstempel via NTP Client abrufen und formatieren           
           import ntplib
           import pytz
           from time import ctime
           from datetime import datetime,timezone

           client = ntplib.NTPClient()
           response = client.request('ptbtime1.ptb.de') # Request an die Physikalisch Technische Bundesanstalt (PTB) in Braunschweig 
           response_timestamp = response.tx_time # Zeitstempel unformatiert als float

           timestamp_utc_from_ntp = datetime.fromtimestamp(response_timestamp, timezone.utc).isoformat(timespec='milliseconds') # UTC
           timestamp_zulu = timestamp_utc_from_ntp[:-6] + 'Z' # ZULU
           timestamp_local = datetime.fromtimestamp(response_timestamp, pytz.timezone('Europe/Berlin')).isoformat(timespec='milliseconds') # +2 Stunden Offset

           print('UTC:',timestamp_utc_from_ntp, '\n', 'Zulu:',timestamp_zulu, '\n', 'Local:',timestamp_local)
           
           """ Ausgabe bspw: UTC: 2019-10-20T18:42:16.634+00:00 
                                         Zulu: 2019-10-20T18:42:16.634Z 
                                         Local: 2019-10-20T20:42:16.634+02:00 
           """
        \end{lstlisting}

\end{frame}